/*
 * Copyright (c) 2011 runner.mei
 *
 * derived from pywbem, written by Tim Potter <tpot@hp.com>, Martin Pool <mbp@hp.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 *
 * Functions to create XML documens and elements conforming to the DMTF
 * standard DSP0201, Representation of CIM in XML, v2.3.1.
 *
 *  http://www.dmtf.org/standards/wbem/DSP201.html
 *  http://www.dmtf.org/standards/published_documents/DSP201.pdf
 *
 * Elements generated by this module should conform to version 2.3.1 of the
 * DTD:
 *
 *  http://www.dmtf.org/standards/wbem/CIM_DTD_V23.dtd
 *
 * There should be one function for each element described in the DTD.  The
 * constructors take builtin Python types, or other cim_xml classes where
 * child elements are required.
 *
 * Every function is a subclass of the Element function and so shares the same
 * attributes and methods, and can be used with the built-in Python XML
 * handling routines.  In particular you can call the toxml() and
 * toprettyxml() methods to generate XML.
 *
 * Note that converting using toprettyxml() inserts whitespace which may
 * corrupt the data in the XML (!!) so you should only do this when
 * displaying to humans who can ignore it, and never for computers.  XML
 * always passes through all non-markup whitespace.
 */

var dom = require("dom-js"),
    util = require("util");


(function(){

  exports._ = _ = {};

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (hasOwnProperty.call(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = util.isArray;

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Is a given variable an arguments object?
  _.isArguments = function(obj) {
    return toString.call(obj) == '[object Arguments]';
  };
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && hasOwnProperty.call(obj, 'callee'));
    };
  }

  // Is a given value a function?
  _.isFunction = function(obj) {
    return toString.call(obj) == '[object Function]';
  };

  // Is a given value a string?
  _.isString = function(obj) {
    return toString.call(obj) == '[object String]';
  };

  // Is a given value a number?
  _.isNumber = function(obj) {
    return toString.call(obj) == '[object Number]';
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    // `NaN` is the only value for which `===` is not reflexive.
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value a date?
  _.isDate = util.isDate;

  // Is the given value a regular expression?
  _.isRegExp = util.isRegExp;


  // Is the given value a Error?
  _.isError = util.isError;

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var item, i, l;
    for(i = 0, l = obj.length; i < l; i++) {
      item = obj[i];
      if (iterator.call(context, item, i, obj)) {
        return item;
      } 
    }
  };

  _.exists = function(obj, value) {
    var item, i, l;
    for(i = 0, l = obj.length; i < l; i++) {
      item = obj[i];
      if (item === value) {
        return true;
      } 
    }
    return false;
  };


  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = function(obj, iterator, context) {
    var results = [], item, i, l;
    if (obj == null) return results;

    for(i = 0, l = obj.length; i < l; i++) {
      item = obj[i];
      results.push(iterator.call(context, item, i, obj));
    }
    return results;
  };

}).call(this);

/* A base function that has a few bonus helper methods. */
exports.CIMElement = CIMElement = function(name){
    dom.Element.call(this, name);

    /* Set the NAME attribute of the element. */
    this.text = function(txt) {
        if(!(txt instanceof dom.Text)){
            txt = new dom.Text(txt);
        }
        this.children = [];
        this.children.push(txt);
    }

    /* Set the NAME attribute of the element. */
    this.name = function(name) {
        this.attributes["NAME"] = name;
    }

    /* Set an attribute if the value is not nil.*/
    this.attribute = function(name, value) {
        this.attributes[name] = value;
    };


    /* Append a child element which can be nil. */
    this.element = function(child) {
        this.children.push(child);
    };

    /** Append a array of children. */
    this.elements = function() {
        for(var i = 0; i < arguments.length; ++ i) {
            if(util.isArray(arguments[i])) {
                this.children = this.children.concat(arguments[i]);
            } else {
                this.children.push(arguments[i]);
            }
        }
    };
};

util.inherits(CIMElement, dom.Element);


/**
 *   The CIM element is the root element of every XML Document that is
 *   valid with respect to this schema.
 *
 *   Each document takes one of two forms; it either contains a single
 *   MESSAGE element defining a CIM message (to be used in the HTTP
 *   mapping), or it contains a DECLARATION element used to declare a
 *   set of CIM objects.
 *
 *   <!ELEMENT CIM (MESSAGE | DECLARATION)>
 *   <!ATTLIST CIM
 *       CIMVERSION CDATA #REQUIRED
 *       DTDVERSION CDATA #REQUIRED>
 */
exports.CIM = CIM = function(data, cim_version, dtd_version) {
    CIMElement.call(this, 'CIM');

    this.attribute('CIMVERSION', cim_version);
    this.attribute('DTDVERSION', dtd_version);
    this.element(data);
};

util.inherits(CIM, CIMElement);


/**************************************************
 Object declaration elements
**************************************************/
/**
 *   The DECLARATION element defines a set of one or more declarations
 *   of CIM objects.  These are partitioned into logical declaration
 *   subsets.
 *
 *   <!ELEMENT DECLARATION (DECLGROUP | DECLGROUP.WITHNAME |
 *                          DECLGROUP.WITHPATH)+>
 */
exports.DECLARATION = DECLARATION = function(data) {
    CIMElement.call(this, 'DECLARATION');
    this.elements(data);
};

util.inherits(DECLARATION, CIMElement);


/**
 *   The DECLGROUP element defines a logical set of CIM Class, Instance
 *   and Qualifier declarations.  It MAY optionally include a
 *   NAMESPACEPATH or LOCALNAMESPACEPATH element which, if present,
 *   defines the common namespace in which all objects within the group
 *   are declared.
 *
 *   <!ELEMENT DECLGROUP ((LOCALNAMESPACEPATH | NAMESPACEPATH)?,
 *                        QUALIFIER.DECLARATION*, VALUE.OBJECT*)>
 */
exports.DECLGROUP = DECLGROUP = function(data) {
    CIMElement.call(this, 'DECLGROUP');
    this.elements(data);
};

util.inherits(DECLGROUP, CIMElement);



/**
 *   The DECLGROUP.WITHNAME element defines a logical set of CIM Class,
 *   Instance and Qualifier declarations.  It MAY optionally include a
 *   NAMESPACEPATH or LOCALNAMESPACEPATH element which, if present,
 *   defines the common namespace in which all objects within the group
 *   are declared.
 *
 *   <!ELEMENT DECLGROUP.WITHNAME ((LOCALNAMESPACEPATH | NAMESPACEPATH)?,
 *                                  QUALIFIER.DECLARATION*, VALUE.NAMEDOBJECT*)>
 */
exports.DECLGROUP_WITHNAME = DECLGROUP_WITHNAME = function(data){
    CIMElement.call(this, 'DECLGROUP.WITHNAME');
    this.elements(data);
};

util.inherits(DECLGROUP_WITHNAME, CIMElement);



/**
 *   The DECLGROUP.WITHPATH element defines a logical set of CIM Class
 *   and Instance declarations.  Each object is declared with its own
 *   independent naming and location information.
 *
 *   <!ELEMENT DECLGROUP.WITHPATH  (VALUE.OBJECTWITHPATH |
 *                                  VALUE.OBJECTWITHLOCALPATH)*>
 */
exports.DECLGROUP_WITHPATH = DECLGROUP_WITHPATH = function(data) {
    CIMElement.call(this, 'DECLGROUP.WITHPATH');
    this.elements(data);
};

util.inherits(DECLGROUP_WITHPATH, CIMElement);


/**
 *   The QUALIFIER.DECLARATION element defines a single CIM Qualifier
 *   declaration.
 *
 *   <!ELEMENT QUALIFIER.DECLARATION (SCOPE?, (VALUE | VALUE.ARRAY)?)>
 *   <!ATTLIST QUALIFIER.DECLARATION
 *        %CIMName;
 *        %CIMType;               #REQUIRED
 *        ISARRAY    (true|false) #IMPLIED
 *        %ArraySize;
 *        %QualifierFlavor;>
 */
function QUALIFIER_DECLARATION(name, type, value, is_array,
                 array_size, qualifier_scopes,
                 overridable, tosubclass
                 toinstance, translatable) {
    CIMElement.call(this, 'QUALIFIER.DECLARATION');
    this.name(name);
    this.attribute('TYPE', type);

    if(is_array) {
        this.attribute('ISARRAY', is_array.toString().toLowerCase());
    }
    if(array_size) {
        this.attribute('ARRAYSIZE', array_size.toString());
    }
    if(overridable) {
        this.attribute('OVERRIDABLE', overridable.toString().toLowerCase());
    }
    if(tosubclass) {
        this.attribute('TOSUBCLASS', tosubclass.toString().toLowerCase());
    }
    if(toinstance) {
        this.attribute('TOINSTANCE', toinstance.toString().toLowerCase());
    }
    if(translatable) {
        this.attribute('TRANSLATABLE', translatable.toString().toLowerCase());
    }

    this.elements(value);
};

util.inherits(QUALIFIER_DECLARATION, CIMElement);


/**
 *   The SCOPE element defines the scope of a QUALIFIER.DECLARATION in
 *   the case that there are restrictions on the scope of the Qualifier
 *   declaration.
 *
 *   <!ELEMENT SCOPE EMPTY>
 *   <!ATTLIST SCOPE
 *        CLASS        (true|false)      'false'
 *        ASSOCIATION  (true|false)      'false'
 *        REFERENCE    (true|false)      'false'
 *        PROPERTY     (true|false)      'false'
 *        METHOD       (true|false)      'false'
 *        PARAMETER    (true|false)      'false'
 *        INDICATION   (true|false)      'false'>
 */
exports.SCOPE = SCOPE = function(scopes) {
    CIMElement.call(this, 'SCOPE');

        if(scopes['any']) {
            scopes = {'CLASS': true,
                      'ASSOCIATION': true,
                      'REFERENCE': true,
                      'PROPERTY': true,
                      'METHOD': true,
                      'PARAMETER': true,
                      'INDICATION': true};
        }

        for(var key in scopes) {
            this.attribute(k, scopes[k].toString()).toLowerCase());
        }

};

util.inherits(SCOPE, CIMElement);

/*************************************************
 Object Value elements
**************************************************/

/**
 *   The VALUE element is used to define a single (non-array and
 *   non-reference) CIM Property value, CIM Qualifier value, or a CIM
 *   Method Parameter value.
 *
 *   <!ELEMENT VALUE (#PCDATA)>
 */
exports.VALUE = VALUE = function(pcdata) {
    CIMElement.call(this, 'VALUE');
    this.text(pcdata);
};

util.inherits(VALUE, CIMElement);


/**
 *   The VALUE.ARRAY element is used to represent the value of a CIM
 *   Property or Qualifier that has an array type.
 *
 *   <!ELEMENT VALUE.ARRAY (VALUE*)>
 */
exports.VALUE_ARRAY = VALUE_ARRAY = function(values) {
    CIMElement.call(this, 'VALUE.ARRAY');
    this.texts(values);
};

util.inherits(VALUE_ARRAY, CIMElement);

/**
 *   The VALUE.REFERENCE element is used to define a single CIM
 *   reference Property value.
 *
 *   <!ELEMENT VALUE.REFERENCE (CLASSPATH | LOCALCLASSPATH | CLASSNAME |
 *                              INSTANCEPATH | LOCALINSTANCEPATH |
 *                              INSTANCENAME)>
 */
exports.VALUE_REFERENCE = VALUE_REFERENCE = function(data) {
    CIMElement.call(this, 'VALUE.REFERENCE');
    this.element(data);
};

util.inherits(VALUE_REFERENCE, CIMElement);


/**
 *   The VALUE.REFARRAY element is used to represent the value of an
 *   array of CIM references.
 *
 *   <!ELEMENT VALUE.REFARRAY (VALUE.REFERENCE | VALUE.NULL)*>
 */
exports.VALUE_REFARRAY = VALUE_REFARRAY = function(data) {
        CIMElement.call(this, 'VALUE.REFARRAY');
        this.elements(data);
};

util.inherits(VALUE_REFARRAY, CIMElement);


/**
 *   The VALUE.OBJECT element is used to define a value which is
 *   comprised of a single CIM Class or Instance definition.
 *
 *   <!ELEMENT VALUE.OBJECT (CLASS | INSTANCE)>
 */
exports.VALUE_OBJECT = VALUE_OBJECT = function(data) {
        CIMElement.call(this, 'VALUE.OBJECT');
        this.element(data);
};

util.inherits(VALUE_OBJECT, CIMElement);

/**
 *   The VALUE.NAMEDINSTANCE element is used to define a value which
 *   is comprised of a single named CIM Instance definition.
 *
 *   <!ELEMENT VALUE.NAMEDINSTANCE (INSTANCENAME, INSTANCE)>
 */
exports.VALUE_NAMEDINSTANCE = VALUE_NAMEDINSTANCE = function(instancename, instance) {
        CIMElement.call(this, 'VALUE.NAMEDINSTANCE');
        this.element(instancename);
        this.element(instance);
};

util.inherits(VALUE_NAMEDINSTANCE, CIMElement);

/**
 *   The VALUE.NAMEDOBJECT element is used to define a value which
 *   is comprised of a single named CIM Class or Instance definition.
 *
 *   <!ELEMENT VALUE.NAMEDOBJECT (CLASS | (INSTANCENAME, INSTANCE))>
 */
exports.VALUE_NAMEDOBJECT = VALUE_NAMEDOBJECT = function(data):
        CIMElement.call(this, 'VALUE.NAMEDOBJECT');
        this.elements(data);
};

util.inherits(VALUE_NAMEDOBJECT, CIMElement);


/**
 *   The VALUE.OBJECTWITHLOCALPATH element is used to define a value
 *   which is comprised of a single CIM Object (Class or Instance)
 *   definition with additional information that defines the local path
 *   to that Object.
 *
 *   <!ELEMENT VALUE.OBJECTWITHLOCALPATH ((LOCALCLASSPATH, CLASS) |
 *                                        (LOCALINSTANCEPATH, INSTANCE))>
 */
exports.VALUE_OBJECTWITHLOCALPATH = VALUE_OBJECTWITHLOCALPATH = function(data1, data2) {
        CIMElement.call(this, 'VALUE.OBJECTWITHLOCALPATH');
        this.element(data1);
        this.element(data2);
};

util.inherits(VALUE_OBJECTWITHLOCALPATH, CIMElement);

/**
 *   The VALUE.OBJECTWITHPATH element is used to define a value
 *   which is comprised of a single CIM Object (Class or Instance)
 *   definition with additional information that defines the absolute
 *   path to that Object.
 *
 *   <!ELEMENT VALUE.OBJECTWITHPATH ((CLASSPATH, CLASS) |
 *                                   (INSTANCEPATH, INSTANCE))>
 */
exports.VALUE_OBJECTWITHPATH = VALUE_OBJECTWITHPATH = function(data1, data2):
        CIMElement.call(this, 'VALUE.OBJECTWITHPATH');
        this.element(data1);
        this.element(data2);
};

util.inherits(VALUE_OBJECTWITHPATH, CIMElement);

/**
 *   The VALUE.NULL element is used to represent a TABLECELL that has
 *   no assigned value.
 *
 *   <!ELEMENT VALUE.NULL EMPTY>
 */
exports.VALUE_NULL = VALUE_NULL = function() {
        CIMElement.call(this, 'VALUE.NULL');
};

util.inherits(VALUE_NULL, CIMElement);


/**************************************************
 Object naming and locating elements
**************************************************/
/**
 *   The NAMESPACEPATH element is used to define a Namespace Path. It
 *   consists of a HOST element and a LOCALNAMESPACE element.
 *
 *   <!ELEMENT NAMESPACEPATH (HOST, LOCALNAMESPACEPATH)>
 */
exports.NAMESPACEPATH = NAMESPACEPATH = function(host, localnamespacepath) {
        CIMElement.call(this, 'NAMESPACEPATH');
        this.element(host);
        this.element(localnamespacepath);
};

util.inherits(NAMESPACEPATH, CIMElement);

/**
 *   The LOCALNAMESPACEPATH element is used to define a local Namespace
 *   path (one without a Host component). It consists of one or more
 *   NAMESPACE elements (one for each namespace in the path).
 *
 *   <!ELEMENT LOCALNAMESPACEPATH (NAMESPACE+)>
 */
exports.LOCALNAMESPACEPATH = LOCALNAMESPACEPATH = function(namespaces):
        CIMElement.call(this, 'LOCALNAMESPACEPATH');
        this.elements(arguments);
};

util.inherits(LOCALNAMESPACEPATH, CIMElement);


/**
 *   The HOST element is used to define a single Host. The element
 *   content MUST specify a legal value for a hostname in accordance
 *   with the CIM specification.
 *
 *   <!ELEMENT HOST (#PCDATA)>
 */
exports.HOST = HOST = function(pcdata) {
        CIMElement.call(this, 'HOST');
        this.text(pcdata);
};

util.inherits(HOST, CIMElement);

/**
 *   The NAMESPACE element is used to define a single Namespace
 *   component of a Namespace path.
 *
 *   <!ELEMENT NAMESPACE EMPTY>
 *   <!ATTLIST NAMESPACE
 *       %CIMName;>
 */
exports.NAMESPACE = NAMESPACE = function(name) {
        CIMElement.call(this, 'NAMESPACE');
        this.name(name);
};

util.inherits(NAMESPACE, CIMElement);

/**
 *   The CLASSPATH element defines the absolute path to a CIM Class. It
 *   is formed from a namespace path and Class name.
 *
 *   <!ELEMENT CLASSPATH (NAMESPACEPATH, CLASSNAME)>
 */
exports.CLASSPATH = CLASSPATH = function(namespacepath, classname) {
        CIMElement.call(this, 'CLASSPATH');
        this.element(namespacepath);
        this.element(classname);
};

util.inherits(CLASSPATH, CIMElement);

/**
 *   The LOCALCLASSPATH element defines the a local path to a CIM
 *   Class. It is formed from a local namespace path and Class name.
 *
 *   <!ELEMENT LOCALCLASSPATH (LOCALNAMESPACEPATH, CLASSNAME)>
 */
exports.LOCALCLASSPATH = LOCALCLASSPATH = function(localnamespacepath, classname) {
        CIMElement.call(this, 'LOCALCLASSPATH');
        this.element(localnamespacepath);
        this.element(classname);
};

util.inherits(LOCALCLASSPATH, CIMElement);

/**
 *   The CLASSNAME element defines the qualifying name of a CIM Class.
 *
 *   <!ELEMENT CLASSNAME EMPTY>
 *   <!ATTLIST CLASSNAME
 *       %CIMName;>
 */
exports.CLASSNAME = CLASSNAME = function(classname) {
        CIMElement.call(this, 'CLASSNAME');
        this.name(classname);
};

util.inherits(CLASSNAME, CIMElement);

/**
 *   The INSTANCEPATH element defines the absolute path to a CIM
 *   Instance. It is comprised of a Namespace path and an Instance Name
 *   (model path).
 *
 *   <!ELEMENT INSTANCEPATH (NAMESPACEPATH, INSTANCENAME)>
 */
exports.INSTANCEPATH = INSTANCEPATH = function(namespacepath, instancename) {
        CIMElement.call(this, 'INSTANCEPATH');
        this.element(namespacepath);
        this.element(instancename);
};

util.inherits(INSTANCEPATH, CIMElement);

/**
 *   The LOCALINSTANCEPATH element defines the local path to a CIM
 *   Instance. It is comprised of a local Namespace path and an
 *   Instance Name (model path).
 *
 *   <!ELEMENT LOCALINSTANCEPATH (LOCALNAMESPACEPATH, INSTANCENAME)>
 */
exports.LOCALINSTANCEPATH = LOCALINSTANCEPATH = function(localpath, instancename) {
        CIMElement.call(this, 'LOCALINSTANCEPATH');
        this.element(localpath);
        this.element(instancename);
};

util.inherits(LOCALINSTANCEPATH, CIMElement);

/**
 *   The INSTANCENAME element defines the location of a CIM Instance
 *   within a Namespace (it is referred to in the CIM Specification
 *   as a Model Path). It is comprised of a function name and a key
 *   binding information.
 *
 *   If the Class has a single key property, then a single KEYVALUE or
 *   VALUE.REFERENCE subelement may be used to describe the
 *   (necessarily) unique key value without a key name. Alternatively a
 *   single KEYBINDING subelement may be used instead.
 *
 *   If the Class has more than one key property, then a KEYBINDING
 *   subelement MUST appear for each key.
 *
 *   If there are no key-bindings specified, the instance is assumed to
 *   be a singleton instance of a keyless Class.
 *
 *   <!ELEMENT INSTANCENAME (KEYBINDING* | KEYVALUE? | VALUE.REFERENCE?)>
 *   <!ATTLIST INSTANCENAME
 *       %ClassName;>
 */
exports.INSTANCENAME = INSTANCENAME = function(classname, data) {
        CIMElement.call(this, 'INSTANCENAME');
        this.attribute('CLASSNAME', classname);
        this.elements(data);
};

util.inherits(INSTANCENAME, CIMElement);

/**
 *   The OBJECTPATH element is used to define a full path to a single
 *   CIM Object (Class or Instance).
 *
 *   <!ELEMENT OBJECTPATH (INSTANCEPATH | CLASSPATH)>
 */
exports.OBJECTPATH = OBJECTPATH = function( data) {
        CIMElement.call(this, 'OBJECTPATH');
        this.element(data);
};

util.inherits(OBJECTPATH, CIMElement);

/**
 *   The KEYBINDING element defines a single key property value binding.
 *
 *   <!ELEMENT KEYBINDING (KEYVALUE | VALUE.REFERENCE)>
 *   <!ATTLIST KEYBINDING
 *       %CIMName;>
 */
exports.KEYBINDING = KEYBINDING = function(name, data) {
        CIMElement.call(this, 'KEYBINDING');
        this.name(name);
        this.element(data);
};

util.inherits(KEYBINDING, CIMElement);

/**
 *   The KEYVALUE element defines a single property key value when the
 *   key property is a non-reference type.
 *
 *   <!ELEMENT KEYVALUE (#PCDATA)>
 *   <!ATTLIST KEYVALUE
 *       VALUETYPE    (string|boolean|numeric)  'string'
 *       %CIMType;    #IMPLIED>
 */
exports.KEYVALUE = KEYVALUE = function(data, value_type = None, cim_type = None) {
        CIMElement.call(this, 'KEYVALUE')

        if(value_type) {
            this.attribute('VALUETYPE', value_type);
        } else {
            this.attribute('VALUETYPE', 'string');
        }

        this.attribute('TYPE', cim_type);

        if(data) {
            this.text(data);
        }
};

util.inherits(KEYVALUE, CIMElement);

/**************************************************
Object definition elements
**************************************************/

/**
 *   The CLASS element defines a single CIM Class.
 *
 *   <!ELEMENT CLASS (QUALIFIER*, (PROPERTY | PROPERTY.ARRAY |
 *                    PROPERTY.REFERENCE)*, METHOD*)>
 *   <!ATTLIST CLASS
 *       %CIMName;
 *       %SuperClass;>
 */
function CLASS(classname, properties, methods,
                 qualifiers, superclass) {
        CIMElement.call(this, 'CLASS');
        this.name(classname);
        this.attribute('SUPERCLASS', superclass);
        this.elements(qualifiers, properties, methods);
};

util.inherits(CLASS, CIMElement);

/**
 *   The INSTANCE element defines a single CIM Instance of a CIM Class.
 *
 *   <!ELEMENT INSTANCE (QUALIFIER*, (PROPERTY | PROPERTY.ARRAY |
 *                                    PROPERTY.REFERENCE)*)>
 *   <!ATTLIST INSTANCE
 *        %ClassName;
 *        xml:lang   NMTOKEN  #IMPLIED>
 */
function INSTANCE(classname, properties, qualifiers ,
                 xml_lang) {
        CIMElement.call(this, 'INSTANCE');
        this.attribute('CLASSNAME', classname);
        this.attribute('xml:lang', xml_lang);
        this.elements(qualifiers, properties);
};

util.inherits(INSTANCE, CIMElement);

/**
 *   The QUALIFIER element defines a single CIM Qualifier. If the
 *   Qualifier has a non-array type, it contains a single VALUE element
 *   representing the value of the Qualifier. If the Qualifier has an
 *   array type, it contains a single VALUE.ARRAY element to represent
 *   the value.
 *
 *   If the Qualifier has no assigned value then the VALUE element MUST
 *   be absent.
 *
 *   <!ELEMENT QUALIFIER ((VALUE | VALUE.ARRAY)?)>
 *   <!ATTLIST QUALIFIER
 *       %CIMName;
 *       %CIMType;               #REQUIRED
 *       %Propagated;
 *       %QualifierFlavor;
 *       xml:lang  NMTOKEN  #IMPLIED>
 */
function QUALIFIER(name, type, value, propagated,
                 overridable, tosubclass, toinstance,
                 translatable, xml_lang):

        CIMElement.call(this, 'QUALIFIER');

        this.name(name);
        this.attribute('TYPE', type);

        if(propagated) {
            this.attribute('PROPAGATED', propagated.toString().toLowerCase());
        }
        if(overridable) {
            this.attribute('OVERRIDABLE', overridable.toString().toLowerCase());
        }
        if(tosubclass) {
            this.attribute('TOSUBCLASS', tosubclass.toString().toLowerCase());
        }
        if(toinstance) {
            this.attribute('TOINSTANCE', toinstance.toString().toLowerCase());
        }
        if(translatable) {
            this.attribute('TRANSLATABLE', translatable.toString().toLowerCase());
        }

        this.attribute('xml:lang', xml_lang);
        this.element(value);
};

util.inherits(QUALIFIER, CIMElement);

/**
 *   The PROPERTY element defines a single (non-array) CIM Property
 *   that is not a reference. It contains a single VALUE element
 *   representing the value of the Property.
 *
 *   If the Property has no assigned value then the VALUE element MUST be
 *   absent.
 *
 *   CIM Reference Properties are described using the
 *   PROPERTY.REFERENCE element.
 *
 *   <!ELEMENT PROPERTY (QUALIFIER*, VALUE?)>
 *   <!ATTLIST PROPERTY
 *       %CIMName;
 *       %ClassOrigin;
 *       %Propagated;
 *       %EmbeddedObject;
 *       %CIMType;           #REQUIRED
 *       xml:lang   NMTOKEN  #IMPLIED>
 */
function PROPERTY(name, type, value, class_origin,
                 propagated, qualifiers, xml_lang,
                 embedded_object) {
        CIMElement.call(this, 'PROPERTY');

        this.name(name);
        this.attribute('TYPE', type);

        this.attribute('CLASSORIGIN', class_origin);

        if(propagated){
            this.attribute('PROPAGATED', propagated.toString().toLowerCase());
        }

        this.attribute('xml:lang', xml_lang);
        this.attribute('EmbeddedObject', embedded_object);

        this.elements(qualifiers);
        this.element(value);
};

util.inherits(PROPERTY, CIMElement);

/**
 *   The PROPERTY.ARRAY element defines a single CIM Property with an
 *   array type. It contains a single VALUE.ARRAY element  representing
 *   the value of the Property.
 *
 *   If the Property has no assigned value then the VALUE.ARRAY element
 *   MUST be absent.
 *
 *   There is no element to model a Property that contains an array of
 *   references as this is not a valid Property type according to CIM.
 *
 *   <!ELEMENT PROPERTY.ARRAY (QUALIFIER*, VALUE.ARRAY?)>
 *   <!ATTLIST PROPERTY.ARRAY
 *      %CIMName;
 *      %CIMType;           #REQUIRED
 *      %ArraySize;
 *      %ClassOrigin;
 *      %Propagated;
 *      %EmbeddedObject;
 *      xml:lang   NMTOKEN  #IMPLIED>
 */
function PROPERTY_ARRAY(name, type, value_array, array_size,
                 class_origin, propagated, qualifiers,
                 xml_lang, embedded_object) {

        CIMElement.call(this, 'PROPERTY.ARRAY');

        this.name(name);
        this.attribute('TYPE', type);

        if(array_size) {
            this.attribute('ARRAYSIZE', array_size.toString());
        }

        this.attribute('CLASSORIGIN', class_origin);
        this.attribute('EmbeddedObject', embedded_object);

        if(propagated){
            this.attribute('PROPAGATED', propagated.toString().toLowerCase());
        }

        this.attribute('xml:lang', xml_lang);

        this.elements(qualifiers);
        this.element(value_array);
};

util.inherits(PROPERTY_ARRAY, CIMElement);

/**
 *   The PROPERTY.REFERENCE element models a single CIM Property with
 *   reference semantics. In future the features of XML Linking may
 *   be used to identify linking elements within the XML Document; as
 *   XML Linking is currently only at Working Draft status no explicit
 *   dependencies have been made at this point.
 *
 *   <!ELEMENT PROPERTY.REFERENCE (QUALIFIER*, VALUE.REFERENCE?)>
 *   <!ATTLIST PROPERTY.REFERENCE
 *       %CIMName;
 *       %ReferenceClass;
 *       %ClassOrigin;
 *       %Propagated;>
 */
function PROPERTY_REFERENCE(name, value_reference, reference_class,
                 class_origin, propagated, qualifiers) {

        CIMElement.call(this, 'PROPERTY.REFERENCE');

        this.name(name);

        this.attribute('REFERENCECLASS', reference_class);
        this.attribute('CLASSORIGIN', class_origin);

        if(propagated) {
            this.attribute('PROPAGATED', propagated.toString().toLowerCase());
        }

        this.elements(qualifiers);
        this.element(value_reference);
};

util.inherits(PROPERTY_REFERENCE, CIMElement);

/**
 *   The METHOD element defines a single CIM Method. It may have
 *   Qualifiers, and zero or more parameters.
 *
 *   The order of the PARAMETER, PARAMETER.REFERENCE, PARAMETER.ARRAY
 *   and PARAMETER.REFARRAY subelements is not significant.
 *
 *   <!ELEMENT METHOD (QUALIFIER*, (PARAMETER | PARAMETER.REFERENCE |
 *                                  PARAMETER.ARRAY | PARAMETER.REFARRAY)*)>
 *   <!ATTLIST METHOD
 *       %CIMName;
 *       %CIMType;          #IMPLIED
 *       %ClassOrigin;
 *       %Propagated;>
 */
function METHOD(name, parameters, return_type,
                 class_origin, propagated, qualifiers) {

        CIMElement.call(this, 'METHOD');

        this.name(name);

        this.attribute('TYPE', return_type);
        this.attribute('CLASSORIGIN', class_origin);

        if(propagated){
            this.attribute('PROPAGATED', propagated.toString().toLowerCase());
        }

        this.elements(qualifiers, parameters);
};

util.inherits(METHOD, CIMElement);

/**
 *   The PARAMETER element defines a single (non-array, non-reference)
 *   Parameter to a CIM Method. The parameter MAY have zero or more
 *   Qualifiers.
 *
 *   <!ELEMENT PARAMETER (QUALIFIER*)>
 *   <!ATTLIST PARAMETER
 *       %CIMName;
 *       %CIMType;      #REQUIRED>
 */
exports.PARAMETER = PARAMETER = function(name, type, qualifiers) {
        CIMElement.call(this, 'PARAMETER')
        this.name(name);
        this.attribute('TYPE', type);
        this.elements(qualifiers);
};

util.inherits(PARAMETER, CIMElement);

/**
 *   The PARAMETER.REFERENCE element defines a single reference
 *   Parameter to a CIM Method. The parameter MAY have zero or more
 *   Qualifiers.
 *
 *   <!ELEMENT PARAMETER.REFERENCE (QUALIFIER*)>
 *   <!ATTLIST PARAMETER.REFERENCE
 *       %CIMName;
 *       %ReferenceClass;>
 */
exports.PARAMETER_REFERENCE = PARAMETER_REFERENCE = function(name, reference_class, qualifiers) {
        CIMElement.call(this, 'PARAMETER.REFERENCE');
        this.name(name);
        this.attribute('REFERENCECLASS', reference_class);
        this.elements(qualifiers);
};

util.inherits(PARAMETER_REFERENCE, CIMElement);

/**
 *   The PARAMETER.ARRAY element defines a single Parameter to a CIM
 *   Method that has an array type. The parameter MAY have zero or more
 *   Qualifiers.
 *
 *   <!ELEMENT PARAMETER.ARRAY (QUALIFIER*)>
 *   <!ATTLIST PARAMETER.ARRAY
 *       %CIMName;
 *       %CIMType;           #REQUIRED
 *       %ArraySize;>
 */
exports.PARAMETER_ARRAY = PARAMETER_ARRAY = function(name, type, array_size, qualifiers) {
        CIMElement.call(this, 'PARAMETER.ARRAY');
        this.name(name);
        this.attribute('TYPE', type);
        if(array_size) {
            this.attribute('ARRAYSIZE', array_size);
        }
        this.elements(qualifiers);
};

util.inherits(PARAMETER_ARRAY, CIMElement);

/**
 *   The PARAMETER.REFARRAY element defines a single Parameter to a CIM
 *   Method that has an array of references type. The parameter MAY
 *   have zero or more Qualifiers.
 *
 *   <!ELEMENT PARAMETER.REFARRAY (QUALIFIER*)>
 *   <!ATTLIST PARAMETER.REFARRAY
 *       %CIMName;
 *       %ReferenceClass;
 *       %ArraySize;>
 */
function PARAMETER_REFARRAY(name, reference_class, array_size,
                 qualifiers) {
        CIMElement.call(this, 'PARAMETER.REFARRAY');
        this.name(name);
        this.attribute('REFERENCECLASS', reference_class);
        if(array_size) {
            this.attribute('ARRAYSIZE', array_size);
        }

        this.elements(qualifiers);
};

util.inherits(PARAMETER_REFARRAY, CIMElement);

/**
 *   The TABLECELL.DECLARATION element describes a TABLECELL that is
 *   not a reference or an array of references.
 *
 *   <!ELEMENT TABLECELL.DECLARATION EMPTY>
 *   <!ATTLIST TABLECELL.DECLARATION
 *       %CIMName;
 *       %CIMType;                    #REQUIRED
 *       ISARRAY         (true|false) "false"
 *       %ARRAYSIZE;
 *       CELLPOS          CDATA       #REQUIRED
 *       SORTPOS          CDATA       #IMPLIED
 *       SORTDIR        (ASC|DESC)    #IMPLIED>
 */
exports.TABLECELL_DECLARATION = TABLECELL_DECLARATION = function(name, type, is_array, array_size, cell_pos, sort_pos, sort_dir){
        CIMElement.call(this, 'PARAMETER.REFARRAY');
        this.name(name);
        this.attribute('REFERENCECLASS', reference_class);
        if(is_array) {
            this.attribute('ISARRAY', "true");
        }
        if(array_size) {
            this.attribute('ARRAYSIZE', array_size);
        }
        if(cell_pos) {
            this.attribute('CELLPOS', cell_pos);
        }
};

util.inherits(PARAMETER_REFARRAY, CIMElement);


/**************************************************
 Message elements
**************************************************/
/**
 *   The MESSAGE element models a single CIM message.  This element is
 *   used as the basis for CIM Operation Messages and CIM Export
 *   Messages.
 *
 *   <!ELEMENT MESSAGE (SIMPLEREQ | MULTIREQ | SIMPLERSP | MULTIRSP |
 *                      SIMPLEEXPREQ | MULTIEXPREQ | SIMPLEEXPRSP |
 *                      MULTIEXPRSP)>
 *   <!ATTLIST MESSAGE
 *   ID CDATA #REQUIRED
 *   PROTOCOLVERSION CDATA #REQUIRED>
 */
exports.MESSAGE = MESSAGE = function(data, message_id, protocol_version) {
        CIMElement.call(this, 'MESSAGE');
        this.attribute('ID', message_id);
        this.attribute('PROTOCOLVERSION', protocol_version);
        this.element(data);
};

util.inherits(MESSAGE, CIMElement);

/**
 *   The MULTIREQ element defines a Multiple CIM Operation request.  It
 *   contains two or more subelements defining the SIMPLEREQ elements
 *   that make up this multiple request.
 *
 *   <!ELEMENT MULTIREQ (SIMPLEREQ, SIMPLEREQ+)>
 */
exports.MULTIREQ = MULTIREQ = function(data) {
        CIMElement.call(this, 'MULTIREQ');
        this.elements(data);
};

util.inherits(MULTIREQ, CIMElement);

/**
 *   The MULTIEXPREQ element defines a Multiple CIM Export request.  It
 *   contains two or more subelements defining the SIMPLEEXPREQ
 *   elements that make up this multiple request.
 *
 *   <!ELEMENT MULTIEXPREQ (SIMPLEEXPREQ, SIMPLEEXPREQ+)>
 */
exports.MULTIEXPREQ = MULTIEXPREQ = function(data) {
        CIMElement.call(this, 'MULTIEXPREQ');
        this.elements(data);
};

util.inherits(MULTIEXPREQ, CIMElement);

/**
 *   The SIMPLEREQ element defines a Simple CIM Operation request.  It
 *   contains either a METHODCALL (extrinsic method) element or an
 *   IMETHODCALL (intrinsic method) element.
 *
 *   <!ELEMENT SIMPLEREQ (IMETHODCALL | METHODCALL)>
 */
exports.SIMPLEREQ = SIMPLEREQ = function(data) {
        CIMElement.call(this, 'SIMPLEREQ');
        this.element(data);
};

util.inherits(MULTIEXPREQ, CIMElement);

/**
 *   The SIMPLEEXPREQ element defines a Simple CIM Export request.  It
 *   contains an EXPMETHODCALL (export method).
 *
 *   <!ELEMENT SIMPLEEXPREQ (EXPMETHODCALL)>
 */
exports.SIMPLEEXPREQ = SIMPLEEXPREQ = function(data){
        CIMElement.call(this, 'SIMPLEEXPREQ');
        this.element(data);
};

util.inherits(SIMPLEEXPREQ, CIMElement);

/**
 *   The IMETHODCALL element defines a single intrinsic method
 *   invocation.  It specifies the target local namespace, followed by
 *   zero or more IPARAMVALUE subelements as the parameter values to be
 *   passed to the method. If the RESPONSEDESTINATION element is
 *   specified, the intrinsic method call MUST be interpreted as an
 *   asynchronous method call.
 *
 *   <!ELEMENT IMETHODCALL (LOCALNAMESPACEPATH, IPARAMVALUE*,
 *                          RESPONSEDESTINATION?)>
 *   <!ATTLIST IMETHODCALL
 *   %CIMName;>
 */
function IMETHODCALL(name, localnamespacepath, iparamvalues
        responsedestination) {
        CIMElement.call(this, 'IMETHODCALL');
        this.name(name);
        this.element(localnamespacepath);
        this.elements(iparamvalues);
        this.element(responsedestination);
};

util.inherits(IMETHODCALL, CIMElement);

/**
 *   The METHODCALL element defines a single method invocation on a
 *   Class or Instance.  It specifies the local path of the target
 *   Class or Instance, followed by zero or more PARAMVALUE subelements
 *   as the parameter values to be passed to the method. If the
 *   RESPONSEDESTINATION element is specified, the method call MUST be
 *   interpreted as an asynchronous method call.
 *
 *   <!ELEMENT METHODCALL ((LOCALINSTANCEPATH | LOCALCLASSPATH), PARAMVALUE*,
 *                         RESPONSEDESTINATION?)>
 *   <!ATTLIST METHODCALL
 *   %CIMName;>
 */
function METHODCALL(name, localpath, paramvalues,
                 responsedestination):
        CIMElement.call(this, 'METHODCALL');
        this.name(name);
        this.element(localpath);
        this.elements(paramvalues);
        this.element(responsedestination);
};

util.inherits(METHODCALL, CIMElement);

/**
 *   The EXPMETHODCALL element defines a single export method
 *   invocation.  It specifies zero or more  <EXPPARAMVALUE>
 *   subelements as the parameter values to be passed to the method.
 *
 *   <!ELEMENT EXPMETHODCALL (EXPPARAMVALUE*)>
 *   <!ATTLIST EXPMETHODCALL
 *   %CIMName;>
 */
exports.EXPMETHODCALL = EXPMETHODCALL = function(name, params):
        CIMElement.call(this, 'EXPMETHODCALL');
        this.name(name);
        this.elements(params);
};

util.inherits(EXPMETHODCALL, CIMElement);

/**
 *   The PARAMVALUE element defines a single extrinsic method named
 *   parameter value. If no subelement is present this indicates that
 *   no value has been supplied for this parameter.
 *
 *   <!ELEMENT PARAMVALUE (VALUE | VALUE.REFERENCE | VALUE.ARRAY |
 *                         VALUE.REFARRAY)?>
 *   <!ATTLIST PARAMVALUE
 *   %CIMName;
 *       %ParamType;    #IMPLIED>
 */
function PARAMVALUE(name, data, paramtype,
                 embedded_object) {
        CIMElement.call(this, 'PARAMVALUE');
        this.name(name);
        this.attribute('PARAMTYPE', paramtype);
        this.attribute('EmbeddedObject', embedded_object);
        this.element(data);
};

util.inherits(PARAMVALUE, CIMElement);

/**
 *   The IPARAMVALUE element defines a single intrinsic method named
 *   parameter value. If no subelement is present this indicates that
 *   no value has been supplied for this parameter.
 *
 *   <!ELEMENT IPARAMVALUE (VALUE | VALUE.ARRAY | VALUE.REFERENCE |
 *                          INSTANCENAME | CLASSNAME | QUALIFIER.DECLARATION |
 *                          CLASS | INSTANCE | VALUE.NAMEDINSTANCE)?>
 *   <!ATTLIST IPARAMVALUE
 *   %CIMName;>
 */
exports.IPARAMVALUE = IPARAMVALUE = function(name, data) {
        CIMElement.call(this, 'IPARAMVALUE');
        this.name(name);
        this.element(data);
};

util.inherits(IPARAMVALUE, CIMElement);


/**
 *   The EXPPARAMVALUE element defines a single export method named
 *   parameter value.  If no subelement is present this indicates that
 *   no value has been supplied for this parameter.
 *
 *   <!ELEMENT EXPPARAMVALUE (INSTANCE? | VALUE? | METHODRESPONSE? |
 *                            IMETHODRESPONSE?)>
 *   <!ATTLIST EXPPARAMVALUE
 *   %CIMName;
 *       %ParamType;  #IMPLIED>
 */
exports.EXPPARAMVALUE = EXPPARAMVALUE = function(name, data, param_type) {
        CIMElement.call(this, 'EXPPARAMVALUE');
        this.name(name);
        this.attribute('PARAMTYPE', param_type);
        this.element(data);
};

util.inherits(EXPPARAMVALUE, CIMElement);

/**
 *   The MULTIRSP element defines a Multiple CIM Operation response.
 *   It contains two or more subelements defining the SIMPLERSP
 *   elements that make up this multiple response.
 *
 *   <!ELEMENT MULTIRSP (SIMPLERSP, SIMPLERSP+)>
 */
exports.MULTIRSP = MULTIRSP = function(data) {
        CIMElement.call(this, 'MULTIRSP');
        this.elements(data);
};

util.inherits(MULTIRSP, CIMElement);

/**
 *   The MULTIEXPRSP element defines a Multiple CIM Export response.
 *   It contains two or more subelements defining the SIMPLEEXPRSP
 *   elements that make up this multiple response.
 *
 *   <!ELEMENT MULTIEXPRSP (SIMPLEEXPRSP, SIMPLEEXPRSP+)>
 */
exports.MULTIEXPRSP = MULTIEXPRSP = function(data) {
        CIMElement.call(this, 'MULTIEXPRSP');
        this.elements(data);
};

util.inherits(MULTIEXPRSP, CIMElement);


/**
 *   The SIMPLERSP element defines a Simple CIM Operation response.  It
 *   contains either a METHODRESPONSE (for extrinsic methods),
 *   IMETHODRESPONSE (for intrinsic methods) or a SIMPLEREQACK
 *   subelement.
 *
 *   <!ELEMENT SIMPLERSP (METHODRESPONSE | IMETHODRESPONSE | SIMPLEREQACK)>
 */
exports.SIMPLERSP = SIMPLERSP = function(data) {
        CIMElement.call(this, 'SIMPLERSP');
        this.element(data);
};

util.inherits(SIMPLERSP, CIMElement);

/**
 *   The SIMPLEEXPRSP element defines a Simple CIM Export response.  It
 *   contains either a EXPMETHODRESPONSE (for export methods)
 *   subelement.
 *
 *   <!ELEMENT SIMPLEEXPRSP (EXPMETHODRESPONSE)>
 */
exports.SIMPLEEXPRSP = SIMPLEEXPRSP = function(data) {
        CIMElement.call(this, 'SIMPLEEXPRSP');
        this.element(data);
};

util.inherits(SIMPLEEXPRSP, CIMElement);

/**
 *   The METHODRESPONSE defines the response to a single CIM extrinsic
 *   method invocation.  It contains either an ERROR subelement (to
 *   report a fundamental error which prevented the method from
 *   executing), or a combination of an optional return value and zero
 *   or more out parameter values.
 *
 *   <!ELEMENT METHODRESPONSE (ERROR | (RETURNVALUE?, PARAMVALUE*))>
 *   <!ATTLIST METHODRESPONSE
 *   %CIMName;>
 */
exports.METHODRESPONSE = METHODRESPONSE = function(name, data) {
        CIMElement.call(this, 'METHODRESPONSE');
        this.name(name);
        this.elements(data);
};

util.inherits(METHODRESPONSE, CIMElement);


/**
 *   The EXPMETHODRESPONSE defines the response to a single export
 *   method invocation.  It contains either an ERROR subelement (to
 *   report a fundamental error which prevented the method from
 *   executing), or an optional return value.
 *
 *   <!ELEMENT EXPMETHODRESPONSE (ERROR | IRETURNVALUE?)>
 *   <!ATTLIST EXPMETHODRESPONSE
 *   %CIMName;>
 */
exports.EXPMETHODRESPONSE = EXPMETHODRESPONSE = function(name, data) {
        CIMElement.call(this, 'EXPMETHODRESPONSE');
        this.name(name);
        this.element(data);
};

util.inherits(EXPMETHODRESPONSE, CIMElement);


/**
 *   The IMETHODRESPONSE defines the response to a single intrinsic CIM
 *   method invocation.  It contains either an ERROR subelement (to
 *   report a fundamental error which prevented the method from
 *   executing), or an optional return value.
 *
 *   <!ELEMENT IMETHODRESPONSE (ERROR | IRETURNVALUE?)>
 *   <!ATTLIST IMETHODRESPONSE
 *   %CIMName;>
 */
exports.IMETHODRESPONSE = IMETHODRESPONSE = function(name, data) {
        CIMElement.call(this, 'IMETHODRESPONSE');
        this.name(name);
        this.element(data);
};

util.inherits(IMETHODRESPONSE, CIMElement);

/**
 *   The ERROR element is used to define a fundamental error which
 *   prevented a method from executing normally. It consists of a
 *   status code, an optional description and zero or more instances
 *   containing detailed information about the error.
 *
 *   <!ELEMENT ERROR (INSTANCE*)>
 *   <!ATTLIST ERROR
 *   CODE CDATA #REQUIRED
 *   DESCRIPTION CDATA #IMPLIED>
 */
exports.ERROR = ERROR = function(code, description, instances) {
        CIMElement.call(this, 'ERROR');
        this.attribute('CODE', code);
        this.attribute('DESCRIPTION', description);
        this.elements(instances);
};

util.inherits(ERROR, CIMElement);


/**
 *   The RETURNVALUE element specifies the value returned from an
 *   extrinsic method call.
 *
 *   <!ELEMENT RETURNVALUE (VALUE | VALUE.REFERENCE)>
 *   <!ATTLIST RETURNVALUE
 *       %ParamType;     #IMPLIED>
 */
exports.RETURNVALUE = RETURNVALUE = function(data, param_type) {
        CIMElement.call(this, 'RETURNVALUE');
        this.attribute('PARAMTYPE', param_type);
        this.element(data);
};

util.inherits(RETURNVALUE, CIMElement);


/**
 *   The IRETURNVALUE element specifies the value returned from an
 *   intrinsic method call.
 *
 *   <!ELEMENT IRETURNVALUE (CLASSNAME* | INSTANCENAME* | VALUE* |
 *                           VALUE.OBJECTWITHPATH* |
 *                           VALUE.OBJECTWITHLOCALPATH* | VALUE.OBJECT* |
 *                           OBJECTPATH* | QUALIFIER.DECLARATION* |
 *                           VALUE.ARRAY? | VALUE.REFERENCE? | CLASS* |
 *                           INSTANCE* | VALUE.NAMEDINSTANCE*)>
 */
exports.IRETURNVALUE = IRETURNVALUE = function(data) {
        CIMElement.call(this, 'IRETURNVALUE');
        this.element(data);
};

util.inherits(IRETURNVALUE, CIMElement);


/**
 *   The RESPONSEDESTINATION element contains an instance that
 *   describes the desired destination for the response.
 *
 *   <!ELEMENT RESPONSEDESTINATON (INSTANCE)>
 */
exports.RESPONSEDESTINATION = RESPONSEDESTINATION = function(data) {
        CIMElement.call(this, 'RESPONSEDESTINATON');
        this.element(data);
};

util.inherits(RESPONSEDESTINATION, CIMElement);

/**
 *   The SIMPLEREQACK defines the acknowledgement response to a Simple
 *   CIM Operation asynchronous request. The ERROR subelement is used
 *   to report a fundamental error which prevented the asynchronous
 *   request from being initiated.
 *
 *   <!ELEMENT SIMPLEREQACK (ERROR?)>
 *   <!ATTLIST SIMPLEREQACK
 *       INSTANCEID CDATA     #REQUIRED>
 */
exports.SIMPLEREQACK = SIMPLEREQACK = function(instanceid, data) {
        CIMElement.call(this, 'SIMPLEREQACK');
        this.attribute('INSTANCEID', instanceid);
        this.element(data);
};

util.inherits(SIMPLEREQACK, CIMElement);





